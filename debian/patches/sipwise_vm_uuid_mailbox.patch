From: Sipwise Development Team <support@sipwise.com>
Date: Mon, 21 Feb 2022 14:17:23 +0100
Subject: sipwise_vm_uuid_mailbox

---
 apps/app_voicemail.c | 783 ++++-----------------------------------------------
 1 file changed, 62 insertions(+), 721 deletions(-)

diff --git a/apps/app_voicemail.c b/apps/app_voicemail.c
index 425f599..a03fe25 100644
--- a/apps/app_voicemail.c
+++ b/apps/app_voicemail.c
@@ -894,7 +894,8 @@ and vm-Old are spelled plural, to make them sound more as folder name than an ad
  * Use ast_vm_user_destroy() to free one of these structures. */
 struct ast_vm_user {
 	char context[MAX_VM_CONTEXT_LEN];/*!< Voicemail context */
-	char mailbox[MAX_VM_MBOX_ID_LEN];/*!< Mailbox id, unique within vm context */
+	char mailbox[MAX_VM_MBOX_ID_LEN]; /*!< granig: the mailbox uuid */
+	char dialed_num[MAX_VM_MBOX_ID_LEN]; /*!< granig: the mailbox number */
 	char password[80];               /*!< Secret pin code, numbers only */
 	char fullname[80];               /*!< Full name, for directory app */
 	char *email;                     /*!< E-mail address */
@@ -1834,6 +1835,12 @@ static void apply_options_full(struct ast_vm_user *retval, struct ast_variable *
 		} else if (!strcasecmp(var->name, "emailbody")) {
 			ast_free(retval->emailbody);
 			retval->emailbody = ast_strdup(substitute_escapes(var->value));
+		} else if (!strcasecmp(var->name, "customer_id")) { /* granig: use uuid instead of number */
+			ast_copy_string(retval->mailbox, var->value, sizeof(retval->mailbox));
+			// ast_log (LOG_DEBUG,"setting mailbox to '%s'\n", var->value);
+		} else if (!strcasecmp(var->name, "mailbox")) { /* granig: but save number for announcement */
+			ast_copy_string(retval->dialed_num, var->value, sizeof(retval->dialed_num));
+			// ast_log (LOG_DEBUG,"setting dialed_num to '%s'\n", var->value);
 #ifdef IMAP_STORAGE
 		} else if (!strcasecmp(var->name, "imapuser")) {
 			ast_copy_string(retval->imapuser, var->value, sizeof(retval->imapuser));
@@ -1916,6 +1923,7 @@ static struct ast_vm_user *find_user_realtime(struct ast_vm_user *ivm, const cha
 			var = ast_load_realtime("voicemail", "mailbox", mailbox, "context", context, SENTINEL);
 		}
 		if (var) {
+			// ast_log (LOG_DEBUG,"call apply_options_full\n");
 			apply_options_full(retval, var);
 			ast_variables_destroy(var);
 		} else {
@@ -1971,6 +1979,7 @@ static struct ast_vm_user *find_user(struct ast_vm_user *ivm, const char *contex
 	}
 	AST_LIST_UNLOCK(&users);
 	if (!vmu) {
+		ast_log(LOG_DEBUG,"call find_user_realtime for '%s@%s'\n", mailbox, context);
 		vmu = find_user_realtime(ivm, context, mailbox);
 	}
 	if (!vmu && !ast_strlen_zero(aliasescontext)) {
@@ -3336,7 +3345,7 @@ static int open_mailbox(struct vm_state *vms, struct ast_vm_user *vmu, int box)
 		return -1;
 	}
 
-	create_dirpath(vms->curdir, sizeof(vms->curdir), vmu->context, vms->username, vms->curbox);
+	create_dirpath(vms->curdir, sizeof(vms->curdir), vmu->context, vms->mailbox, vms->curbox);
 
 	/* Check Quota */
 	if  (box == 0)  {
@@ -5263,7 +5272,8 @@ static void prep_email_sub_vars(struct ast_channel *ast, struct ast_vm_user *vmu
 	snprintf(num, sizeof(num), "%d", msgnum);
 	pbx_builtin_setvar_helper(ast, "VM_MSGNUM", num);
 	pbx_builtin_setvar_helper(ast, "VM_CONTEXT", context);
-	pbx_builtin_setvar_helper(ast, "VM_MAILBOX", mailbox);
+	pbx_builtin_setvar_helper(ast, "VM_MAILBOX", vmu->dialed_num);
+	pbx_builtin_setvar_helper(ast, "VM_UUID", vmu->mailbox);
 	pbx_builtin_setvar_helper(ast, "VM_CALLERID", (!ast_strlen_zero(cidname) || !ast_strlen_zero(cidnum)) ?
 		ast_callerid_merge(callerid, sizeof(callerid), cidname, cidnum, NULL) : "an unknown caller");
 	pbx_builtin_setvar_helper(ast, "VM_CIDNAME", (!ast_strlen_zero(cidname) ? cidname : "an unknown caller"));
@@ -6090,7 +6100,7 @@ static int get_date(char *s, int len)
 	return ast_strftime(s, len, "%a %b %e %r UTC %Y", &tm);
 }
 
-static int invent_message(struct ast_channel *chan, char *context, char *ext, int busy, char *ecodes)
+static int invent_message(struct ast_channel *chan, char *context, char *ext, char *dialed_num, int busy, char *ecodes)
 {
 	int res;
 	char fn[PATH_MAX];
@@ -6113,12 +6123,11 @@ static int invent_message(struct ast_channel *chan, char *context, char *ext, in
 	} else {
 		/* Dispose just in case */
 		DISPOSE(fn, -1);
-		res = ast_stream_and_wait(chan, "vm-theperson", ecodes);
-		if (res)
-			return res;
-		res = ast_say_digit_str(chan, ext, ecodes, ast_channel_language(chan));
-		if (res)
+		res = ast_say_digit_str(chan, dialed_num, ecodes, ast_channel_language(chan));
+		if (res) {
+			ast_log(LOG_WARNING, "failed to stream/wait '%s'\n", dialed_num);
 			return res;
+		}
 	}
 	res = ast_stream_and_wait(chan, busy ? "vm-isonphone" : "vm-isunavail", ecodes);
 	return res;
@@ -6161,6 +6170,7 @@ static int count_messages_in_folder(struct odbc_obj *odbc, const char *context,
 	}
 
 	*messages = atoi(rowdata);
+	ast_log(LOG_DEBUG, "inboxcount/%s: %d\n", context, *messages);
 	SQLFreeHandle(SQL_HANDLE_STMT, stmt);
 
 	SCOPE_EXIT_RTN_VALUE(0, "messages: %d\n", *messages);
@@ -6609,10 +6619,11 @@ static int inboxcount(const char *mailbox, int *newmsgs, int *oldmsgs)
 	return res;
 }
 
-static void run_externnotify(const char *context, const char *extension, const char *flag)
+static void run_externnotify(const char *context, const char *extension, const char *flag, const char *dialed_num)
 {
 	char arguments[255];
 	char ext_context[256] = "";
+	char number[256] = "";
 	int newvoicemails = 0, oldvoicemails = 0, urgentvoicemails = 0;
 	struct ast_smdi_mwi_message *mwi_msg;
 
@@ -6621,6 +6632,9 @@ static void run_externnotify(const char *context, const char *extension, const c
 	else
 		ast_copy_string(ext_context, extension, sizeof(ext_context));
 
+	if (!ast_strlen_zero(dialed_num))
+		ast_copy_string(number, dialed_num, sizeof(number));
+
 	if (smdi_iface) {
 		if (ast_app_has_voicemail(ext_context, NULL))
 			ast_smdi_mwi_set(smdi_iface, extension);
@@ -6641,12 +6655,15 @@ static void run_externnotify(const char *context, const char *extension, const c
 	}
 
 	if (!ast_strlen_zero(externnotify)) {
+		ast_log(LOG_DEBUG, "Perform inboxcount on context '%s' and number '%s'\n", ext_context, number);
 		if (inboxcount2(ext_context, &urgentvoicemails, &newvoicemails, &oldvoicemails)) {
 			ast_log(AST_LOG_ERROR, "Problem in calculating number of voicemail messages available for extension %s\n", extension);
+		} else if (ast_strlen_zero(number) || !strcmp(extension, number)) {
+			ast_log(AST_LOG_WARNING, "Missing user number to run externnotify on context '%s'\n", ext_context);
 		} else {
 			snprintf(arguments, sizeof(arguments), "%s %s %s %d %d %d &",
 				externnotify, S_OR(context, "\"\""),
-				extension, newvoicemails,
+				number, newvoicemails,
 				oldvoicemails, urgentvoicemails);
 			ast_debug(1, "Executing %s\n", arguments);
 			ast_safe_system(arguments);
@@ -7085,7 +7102,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 
 	/* Setup pre-file if appropriate */
 	if (strcmp(vmu->context, "default"))
-		snprintf(ext_context, sizeof(ext_context), "%s@%s", ext, vmu->context);
+		snprintf(ext_context, sizeof(ext_context), "%s@%s", vmu->mailbox, vmu->context);
 	else
 		ast_copy_string(ext_context, vmu->mailbox, sizeof(ext_context));
 
@@ -7095,18 +7112,18 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 	   Depending on the flag set in options.
 	*/
 	if (ast_test_flag(options, OPT_BUSY_GREETING)) {
-		snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, ext);
+		snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 	} else if (ast_test_flag(options, OPT_UNAVAIL_GREETING)) {
-		snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, ext);
+		snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 	}
 	ast_trace(-1, "prefile: %s\n", prefile);
 	/* Set the path to the tmpfile as
 		VM_SPOOL_DIR/context/ext/temp
 	   and attempt to create the folder structure.
 	*/
-	snprintf(tempfile, sizeof(tempfile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, ext);
+	snprintf(tempfile, sizeof(tempfile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 	ast_trace(-1, "tempfile: %s\n", tempfile);
-	if ((res = create_dirpath(tmpdir, sizeof(tmpdir), vmu->context, ext, "tmp"))) {
+	if ((res = create_dirpath(tmpdir, sizeof(tmpdir), vmu->context, vmu->mailbox, "tmp"))) {
 		free_user(vmu);
 		ast_free(tmp);
 		SCOPE_EXIT_LOG_RTN_VALUE(-1, LOG_WARNING,
@@ -7122,7 +7139,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 
 	/* It's easier just to try to make it than to check for its existence */
 #ifndef IMAP_STORAGE
-	create_dirpath(dir, sizeof(dir), vmu->context, ext, "INBOX");
+	create_dirpath(dir, sizeof(dir), vmu->context, vmu->mailbox, "INBOX");
 #else
 	snprintf(dir, sizeof(dir), "%simap", VM_SPOOL_DIR);
 	if (mkdir(dir, VOICEMAIL_DIR_MODE) && errno != EEXIST) {
@@ -7171,9 +7188,9 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 	/* Play the beginning intro if desired */
 	if (!ast_strlen_zero(prefile)) {
 #if defined(ODBC_STORAGE)
-		int success = SCOPE_CALL_WITH_INT_RESULT(-1, RETRIEVE, prefile, -1, ext, context);
+		int success = SCOPE_CALL_WITH_INT_RESULT(-1, RETRIEVE, prefile, -1, vmu->mailbox, context);
 #elif defined(IMAP_STORAGE)
-        SCOPE_CALL(-1, RETRIEVE, prefile, -1, ext, context);
+        SCOPE_CALL(-1, RETRIEVE, prefile, -1, vmu->mailbox, context);
 #endif
 
 		if (ast_fileexists(prefile, NULL, NULL) > 0) {
@@ -7194,7 +7211,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 #endif
 		} else {
 			ast_trace(-1, "%s doesn't exist, doing what we can\n", prefile);
-			res = invent_message(chan, vmu->context, ext, ast_test_flag(options, OPT_BUSY_GREETING), ecodes);
+			res = invent_message(chan, vmu->context, vmu->mailbox, vmu->dialed_num, ast_test_flag(options, OPT_BUSY_GREETING), ecodes);
 		}
 		SCOPE_CALL(-1, DISPOSE, prefile, -1);
 		if (res < 0) {
@@ -7292,7 +7309,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 			ast_free(tmp);
 			return -1;
 		}
-		if (!(vms = get_vm_state_by_mailbox(ext, context, 0))) {
+		if (!(vms = get_vm_state_by_mailbox(vmu->mailbox, context, 0))) {
 		/* It is possible under certain circumstances that inboxcount did not
 		 * create a vm_state when it was needed. This is a catchall which will
 		 * rarely be used.
@@ -7361,7 +7378,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 				S_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, NULL),
 				"Unknown");
 			ast_store_realtime("voicemail_data",
-				"origmailbox", ext,
+				"origmailbox", vmu->mailbox,
 				"context", ast_channel_context(chan),
 				"exten", ast_channel_exten(chan),
 				"priority", priority,
@@ -7399,7 +7416,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 				"origtime=%ld\n"
 				"category=%s\n"
 				"msg_id=%s\n",
-				ext,
+				vmu->mailbox,
 				ast_channel_context(chan),
 				ast_channel_exten(chan),
 				S_COR(ast_channel_redirecting(chan)->from.number.valid,
@@ -7428,7 +7445,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 		   leaving the message. So we update the directory where we want this
 		   message to go. */
 		if (!strcmp(flag, "Urgent")) {
-			create_dirpath(dir, sizeof(dir), vmu->context, ext, "Urgent");
+			create_dirpath(dir, sizeof(dir), vmu->context, vmu->mailbox, "Urgent");
 		}
 
 		if (txt) {
@@ -7665,7 +7682,7 @@ static int save_to_folder(struct ast_vm_user *vmu, struct vm_state *vms, int msg
 	return res;
 #else
 	char *dir = vms->curdir;
-	char *username = vms->username;
+	char *username = vmu->mailbox;
 	char *context = vmu->context;
 	char sfn[PATH_MAX];
 	char dfn[PATH_MAX];
@@ -8338,197 +8355,6 @@ static int get_folder2(struct ast_channel *chan, char *fn, int start)
 	return res;
 }
 
-/*!
- * \brief presents the option to prepend to an existing message when forwarding it.
- * \param chan
- * \param vmu
- * \param curdir
- * \param curmsg
- * \param vm_fmts
- * \param context
- * \param record_gain
- * \param duration
- * \param vms
- * \param flag
- *
- * Presents a prompt for 1 to prepend the current message, 2 to forward the message without prepending, or * to return to the main menu.
- *
- * This is invoked from forward_message() when performing a forward operation (option 8 from main menu).
- * \return zero on success, -1 on error.
- */
-static int vm_forwardoptions(struct ast_channel *chan, struct ast_vm_user *vmu, char *curdir,
-	int curmsg, char *vm_fmts, char *context, signed char record_gain, long *duration,
-	struct vm_state *vms, char *flag)
-{
-	int cmd = 0;
-	int retries = 0, prepend_duration = 0, already_recorded = 0;
-	char msgfile[PATH_MAX], backup[PATH_MAX], backup_textfile[PATH_MAX];
-	char textfile[PATH_MAX];
-	struct ast_config *msg_cfg;
-	struct ast_flags config_flags = { CONFIG_FLAG_NOCACHE };
-#ifndef IMAP_STORAGE
-	signed char zero_gain = 0;
-#else
-	const char *msg_id = NULL;
-#endif
-	const char *duration_str;
-	SCOPE_ENTER(3, "mbox: %s msgnum: %d curdir: %s", vmu->mailbox, curmsg, curdir);
-
-	/* Must always populate duration correctly */
-	make_file(msgfile, sizeof(msgfile), curdir, curmsg);
-	ast_trace(-1, "msgfile: %s\n", msgfile);
-	strcpy(textfile, msgfile);
-	strcpy(backup, msgfile);
-	strcpy(backup_textfile, msgfile);
-	strncat(textfile, ".txt", sizeof(textfile) - strlen(textfile) - 1);
-	strncat(backup, "-bak", sizeof(backup) - strlen(backup) - 1);
-	strncat(backup_textfile, "-bak.txt", sizeof(backup_textfile) - strlen(backup_textfile) - 1);
-
-	if ((msg_cfg = ast_config_load(textfile, config_flags)) && valid_config(msg_cfg) && (duration_str = ast_variable_retrieve(msg_cfg, "message", "duration"))) {
-		*duration = atoi(duration_str);
-	} else {
-		*duration = 0;
-	}
-
-	while ((cmd >= 0) && (cmd != 't') && (cmd != '*')) {
-		if (cmd)
-			retries = 0;
-		switch (cmd) {
-		case '1':
-
-#ifdef IMAP_STORAGE
-			/* Record new intro file */
-			if (msg_cfg && msg_cfg != CONFIG_STATUS_FILEINVALID) {
-				msg_id = ast_variable_retrieve(msg_cfg, "message", "msg_id");
-			}
-			make_file(vms->introfn, sizeof(vms->introfn), curdir, curmsg);
-			strncat(vms->introfn, "intro", sizeof(vms->introfn));
-			ast_play_and_wait(chan, "vm-record-prepend");
-			ast_play_and_wait(chan, "beep");
-			cmd = play_record_review(chan, NULL, vms->introfn, vmu->maxsecs, vm_fmts, 1, vmu, (int *) duration, NULL, NULL, record_gain, vms, flag, msg_id, 1);
-			if (cmd == -1) {
-				break;
-			}
-			cmd = 't';
-#else
-
-			/* prepend a message to the current message, update the metadata and return */
-			ast_trace(-1, "Prepending to message %d\n", curmsg);
-
-			make_file(msgfile, sizeof(msgfile), curdir, curmsg);
-			ast_trace(-1, "msgfile: %s\n", msgfile);
-
-			strcpy(textfile, msgfile);
-			strncat(textfile, ".txt", sizeof(textfile) - 1);
-			*duration = 0;
-
-			/* if we can't read the message metadata, stop now */
-			if (!valid_config(msg_cfg)) {
-				cmd = 0;
-				break;
-			}
-
-			/* Back up the original file, so we can retry the prepend and restore it after forward. */
-#ifndef IMAP_STORAGE
-			if (already_recorded) {
-				ast_trace(-1, "Restoring '%s' to '%s'\n", backup, msgfile);
-				ast_filecopy(backup, msgfile, NULL);
-				copy(backup_textfile, textfile);
-			}
-			else {
-				ast_trace(-1, "Backing up '%s' to '%s'\n", backup, msgfile);
-				ast_filecopy(msgfile, backup, NULL);
-				copy(textfile, backup_textfile);
-			}
-#endif
-			already_recorded = 1;
-
-			if (record_gain)
-				ast_channel_setoption(chan, AST_OPTION_RXGAIN, &record_gain, sizeof(record_gain), 0);
-
-			cmd = SCOPE_CALL_WITH_INT_RESULT(-1, ast_play_and_prepend, chan, NULL, msgfile, 0, vm_fmts, &prepend_duration, NULL, 1, silencethreshold, maxsilence);
-
-			if (cmd == 'S') { /* If we timed out, tell the user it didn't work properly and clean up the files */
-				ast_stream_and_wait(chan, vm_pls_try_again, ""); /* this might be removed if a proper vm_prepend_timeout is ever recorded */
-				ast_stream_and_wait(chan, vm_prepend_timeout, "");
-				ast_filerename(backup, msgfile, NULL);
-			}
-
-			if (record_gain)
-				ast_channel_setoption(chan, AST_OPTION_RXGAIN, &zero_gain, sizeof(zero_gain), 0);
-
-
-			if ((duration_str = ast_variable_retrieve(msg_cfg, "message", "duration")))
-				*duration = atoi(duration_str);
-
-			if (prepend_duration) {
-				struct ast_category *msg_cat;
-				/* need enough space for a maximum-length message duration */
-				char duration_buf[12];
-
-				*duration += prepend_duration;
-				ast_trace(-1, "Prepending duration: %d  total duration: %ld\n", prepend_duration, *duration);
-				msg_cat = ast_category_get(msg_cfg, "message", NULL);
-				snprintf(duration_buf, sizeof(duration_buf), "%ld", *duration);
-				if (!ast_variable_update(msg_cat, "duration", duration_buf, NULL, 0)) {
-					ast_config_text_file_save(textfile, msg_cfg, "app_voicemail");
-				}
-			}
-
-#endif
-			break;
-		case '2':
-			/* NULL out introfile so we know there is no intro! */
-#ifdef IMAP_STORAGE
-			*vms->introfn = '\0';
-#endif
-			cmd = 't';
-			break;
-		case '*':
-			cmd = '*';
-			break;
-		default:
-			/* If time_out and return to menu, reset already_recorded */
-			already_recorded = 0;
-
-			cmd = ast_play_and_wait(chan, "vm-forwardoptions");
-				/* "Press 1 to prepend a message or 2 to forward the message without prepending" */
-			if (!cmd) {
-				cmd = ast_play_and_wait(chan, "vm-starmain");
-				/* "press star to return to the main menu" */
-			}
-			if (!cmd) {
-				cmd = ast_waitfordigit(chan, 6000);
-			}
-			if (!cmd) {
-				retries++;
-			}
-			if (retries > 3) {
-				cmd = '*'; /* Let's cancel this beast */
-			}
-			ast_test_suite_event_notify("USERPRESS", "Message: User pressed %c\r\nDTMF: %c",
-				isprint(cmd) ? cmd : '?', isprint(cmd) ? cmd : '?');
-		}
-	}
-
-	if (valid_config(msg_cfg))
-		ast_config_destroy(msg_cfg);
-	if (prepend_duration)
-		*duration = prepend_duration;
-
-	if (already_recorded && cmd == -1) {
-		/* restore original message if prepention cancelled */
-		ast_trace(-1, "Restoring '%s' to '%s'\n", backup, msgfile);
-		ast_filerename(backup, msgfile, NULL);
-		rename(backup_textfile, textfile);
-	}
-
-	if (cmd == 't' || cmd == 'S') { /* XXX entering this block with a value of 'S' is probably no longer possible. */
-		cmd = 0;
-	}
-	SCOPE_EXIT_RTN_VALUE(cmd, "Done. CMD: %d %c\n", cmd, cmd >= 32 && cmd < 127 ? cmd : '?');
-}
-
 static void queue_mwi_event(const char *channel_id, const char *box, int urgent, int new, int old)
 {
 	char *mailbox;
@@ -8648,7 +8474,7 @@ static int notify_new_message(struct ast_channel *chan, struct ast_vm_user *vmu,
 		ast_app_inboxcount2(ext_context, &urgentmsgs, &newmsgs, &oldmsgs);
 
 	queue_mwi_event(ast_channel_uniqueid(chan), ext_context, urgentmsgs, newmsgs, oldmsgs);
-	run_externnotify(vmu->context, vmu->mailbox, flag);
+	run_externnotify(vmu->context, vmu->mailbox, flag, vmu->dialed_num);
 
 #ifdef IMAP_STORAGE
 	vm_delete(fn);  /* Delete the file, but not the IMAP message */
@@ -8661,378 +8487,6 @@ static int notify_new_message(struct ast_channel *chan, struct ast_vm_user *vmu,
 	return 0;
 }
 
-/*!
- * \brief Sends a voicemail message to a mailbox recipient.
- * \param chan
- * \param context
- * \param vms
- * \param sender
- * \param fmt
- * \param is_new_message Used to indicate the mode for which this method was invoked.
- *             Will be 0 when called to forward an existing message (option 8)
- *             Will be 1 when called to leave a message (option 3->5)
- * \param record_gain
- * \param urgent
- *
- * Reads the destination mailbox(es) from keypad input for CID, or if use_directory feature is enabled, the Directory.
- *
- * When in the leave message mode (is_new_message == 1):
- *   - allow the leaving of a message for ourselves. (Will not allow us to forward a message to ourselves, when is_new_message == 0).
- *   - attempt to determine the context and mailbox, and then invoke leave_message() function to record and store the message.
- *
- * When in the forward message mode (is_new_message == 0):
- *   - retrieves the current message to be forwarded
- *   - copies the original message to a temporary file, so updates to the envelope can be done.
- *   - determines the target mailbox and folders
- *   - copies the message into the target mailbox, using copy_message() or by generating the message into an email attachment if using imap folders.
- *
- * \return zero on success, -1 on error.
- */
-static int forward_message(struct ast_channel *chan, char *context, struct vm_state *vms, struct ast_vm_user *sender, char *fmt, int is_new_message, signed char record_gain, int urgent)
-{
-#ifdef IMAP_STORAGE
-	int todircount = 0;
-	struct vm_state *dstvms;
-#endif
-	char username[70]="";
-	char fn[PATH_MAX]; /* for playback of name greeting */
-	char ecodes[16] = "#";
-	int res = 0, cmd = 0;
-	struct ast_vm_user *receiver = NULL, *vmtmp;
-	AST_LIST_HEAD_NOLOCK_STATIC(extensions, ast_vm_user);
-	char *stringp;
-	const char *s;
-	const char mailbox_context[256];
-	int saved_messages = 0;
-	int valid_extensions = 0;
-	char *dir;
-	int curmsg;
-	char urgent_str[7] = "";
-	int prompt_played = 0;
-#ifndef IMAP_STORAGE
-	char msgfile[PATH_MAX], textfile[PATH_MAX], backup[PATH_MAX], backup_textfile[PATH_MAX];
-#endif
-	SCOPE_ENTER(3, "%s: user: %s dir: %s msg: %d\n", ast_channel_name(chan),
-		vms->username, vms->curdir, vms->curmsg);
-
-	if (ast_test_flag((&globalflags), VM_FWDURGAUTO)) {
-		ast_copy_string(urgent_str, urgent ? "Urgent" : "", sizeof(urgent_str));
-	}
-
-	if (vms == NULL) {
-		SCOPE_EXIT_RTN_VALUE(-1, "vms is NULL\n");
-	}
-	dir = vms->curdir;
-	curmsg = vms->curmsg;
-
-	ast_test_suite_event_notify("FORWARD", "Message: entering forward message menu");
-	while (!res && !valid_extensions) {
-		int use_directory = 0;
-		if (ast_test_flag((&globalflags), VM_DIRECTFORWARD)) {
-			int done = 0;
-			int retries = 0;
-			cmd = 0;
-			while ((cmd >= 0) && !done ){
-				if (cmd)
-					retries = 0;
-				switch (cmd) {
-				case '1':
-					use_directory = 0;
-					done = 1;
-					break;
-				case '2':
-					use_directory = 1;
-					done = 1;
-					break;
-				case '*':
-					cmd = 't';
-					done = 1;
-					break;
-				default:
-					/* Press 1 to enter an extension press 2 to use the directory */
-					cmd = ast_play_and_wait(chan, "vm-forward");
-					if (!cmd) {
-						cmd = ast_waitfordigit(chan, 3000);
-					}
-					if (!cmd) {
-						retries++;
-					}
-					if (retries > 3) {
-						cmd = 't';
-						done = 1;
-					}
-					ast_test_suite_event_notify("USERPRESS", "Message: User pressed %c\r\nDTMF: %c",
-						isprint(cmd) ? cmd : '?', isprint(cmd) ? cmd : '?');
-				}
-			}
-			if (cmd < 0 || cmd == 't')
-				break;
-		}
-
-		if (use_directory) {
-			/* use app_directory */
-
-			struct ast_app* directory_app;
-
-			directory_app = pbx_findapp("Directory");
-			if (directory_app) {
-				char vmcontext[256];
-				char old_context[strlen(ast_channel_context(chan)) + 1];
-				char old_exten[strlen(ast_channel_exten(chan)) + 1];
-				int old_priority;
-				/* make backup copies */
-				strcpy(old_context, ast_channel_context(chan)); /* safe */
-				strcpy(old_exten, ast_channel_exten(chan)); /* safe */
-				old_priority = ast_channel_priority(chan);
-
-				/* call the Directory, changes the channel */
-				snprintf(vmcontext, sizeof(vmcontext), "%s,,v", context ? context : "default");
-				res = pbx_exec(chan, directory_app, vmcontext);
-
-				ast_copy_string(username, ast_channel_exten(chan), sizeof(username));
-
-				/* restore the old context, exten, and priority */
-				ast_channel_context_set(chan, old_context);
-				ast_channel_exten_set(chan, old_exten);
-				ast_channel_priority_set(chan, old_priority);
-			} else {
-				ast_log(AST_LOG_WARNING, "Could not find the Directory application, disabling directory_forward\n");
-				ast_clear_flag((&globalflags), VM_DIRECTFORWARD);
-			}
-		} else {
-			/* Ask for an extension */
-			res = ast_streamfile(chan, "vm-extension", ast_channel_language(chan));	/* "extension" */
-			prompt_played++;
-			if (res || prompt_played > 4)
-				break;
-			if ((res = ast_readstring(chan, username, sizeof(username) - 1, 2000, 10000, "#")) < 0)
-				break;
-		}
-
-		/* start all over if no username */
-		if (ast_strlen_zero(username))
-			continue;
-		stringp = username;
-		s = strsep(&stringp, "*");
-		/* start optimistic */
-		valid_extensions = 1;
-		while (s) {
-			snprintf((char*)mailbox_context, sizeof(mailbox_context), "%s@%s", s, context ? context : "default");
-			if ((is_new_message == 1 || strcmp(s, sender->mailbox)) && (receiver = find_user(NULL, context, s))) {
-				int oldmsgs;
-				int newmsgs;
-				int capacity;
-
-				if (inboxcount(mailbox_context, &newmsgs, &oldmsgs)) {
-					ast_log(LOG_ERROR, "Problem in calculating number of voicemail messages available for extension %s\n", mailbox_context);
-					/* Shouldn't happen, but allow trying another extension if it does */
-					res = ast_play_and_wait(chan, "pbx-invalid");
-					valid_extensions = 0;
-					break;
-				}
-#ifdef IMAP_STORAGE
-				if (!(dstvms = get_vm_state_by_mailbox(s, context, 0))) {
-					if (!(dstvms = create_vm_state_from_user(receiver))) {
-						ast_log(AST_LOG_ERROR, "Couldn't allocate necessary space\n");
-						/* Shouldn't happen, but allow trying another extension if it does */
-						res = ast_play_and_wait(chan, "pbx-invalid");
-						valid_extensions = 0;
-						break;
-					}
-				}
-				check_quota(dstvms, imapfolder);
-				if (dstvms->quota_limit && dstvms->quota_usage >= dstvms->quota_limit) {
-					ast_log(LOG_NOTICE, "Mailbox '%s' is exceeded quota %u >= %u\n", mailbox_context, dstvms->quota_usage, dstvms->quota_limit);
-					res = ast_play_and_wait(chan, "vm-mailboxfull");
-					valid_extensions = 0;
-					while ((vmtmp = AST_LIST_REMOVE_HEAD(&extensions, list))) {
-						inprocess_count(vmtmp->mailbox, vmtmp->context, -1);
-						free_user(vmtmp);
-					}
-					break;
-				}
-#endif
-				capacity = receiver->maxmsg - inprocess_count(receiver->mailbox, receiver->context, +1);
-				if ((newmsgs + oldmsgs) >= capacity) {
-					ast_log(LOG_NOTICE, "Mailbox '%s' is full with capacity of %d, prompting for another extension.\n", mailbox_context, capacity);
-					res = ast_play_and_wait(chan, "vm-mailboxfull");
-					valid_extensions = 0;
-					while ((vmtmp = AST_LIST_REMOVE_HEAD(&extensions, list))) {
-						inprocess_count(vmtmp->mailbox, vmtmp->context, -1);
-						free_user(vmtmp);
-					}
-					inprocess_count(receiver->mailbox, receiver->context, -1);
-					break;
-				}
-				AST_LIST_INSERT_HEAD(&extensions, receiver, list);
-			} else {
-				/* XXX Optimization for the future.  When we encounter a single bad extension,
-				 * bailing out on all of the extensions may not be the way to go.  We should
-				 * probably just bail on that single extension, then allow the user to enter
-				 * several more. XXX
-				 */
-				while ((receiver = AST_LIST_REMOVE_HEAD(&extensions, list))) {
-					free_user(receiver);
-				}
-				ast_log(LOG_NOTICE, "'%s' is not a valid mailbox\n", mailbox_context);
-				/* "I am sorry, that's not a valid extension.  Please try again." */
-				res = ast_play_and_wait(chan, "pbx-invalid");
-				valid_extensions = 0;
-				break;
-			}
-
-			/* play name if available, else play extension number */
-			snprintf(fn, sizeof(fn), "%s%s/%s/greet", VM_SPOOL_DIR, receiver->context, s);
-			SCOPE_CALL(-1, RETRIEVE, fn, -1, s, receiver->context);
-			if (ast_fileexists(fn, NULL, NULL) > 0) {
-				res = ast_stream_and_wait(chan, fn, ecodes);
-				if (res) {
-					SCOPE_CALL(-1, DISPOSE, fn, -1);
-					return res;
-				}
-			} else {
-				res = ast_say_digit_str(chan, s, ecodes, ast_channel_language(chan));
-			}
-			SCOPE_CALL(-1, DISPOSE, fn, -1);
-
-			s = strsep(&stringp, "*");
-		}
-		/* break from the loop of reading the extensions */
-		if (valid_extensions)
-			break;
-	}
-	/* check if we're clear to proceed */
-	if (AST_LIST_EMPTY(&extensions) || !valid_extensions)
-		return res;
-	if (is_new_message == 1) {
-		struct leave_vm_options leave_options;
-		char mailbox[AST_MAX_EXTENSION * 2 + 2];
-		snprintf(mailbox, sizeof(mailbox), "%s@%s", username, context);
-
-		/* Send VoiceMail */
-		memset(&leave_options, 0, sizeof(leave_options));
-		leave_options.record_gain = record_gain;
-		leave_options.beeptone = "beep";
-		cmd = SCOPE_CALL_WITH_INT_RESULT(-1, leave_voicemail, chan, mailbox, &leave_options);
-	} else {
-		/* Forward VoiceMail */
-		long duration = 0;
-		struct vm_state vmstmp;
-		int copy_msg_result = 0;
-#ifdef IMAP_STORAGE
-		char filename[PATH_MAX];
-		struct ast_flags config_flags = { CONFIG_FLAG_NOCACHE };
-		const char *msg_id = NULL;
-		struct ast_config *msg_cfg;
-#endif
-		memcpy(&vmstmp, vms, sizeof(vmstmp));
-
-		SCOPE_CALL(-1, RETRIEVE, dir, curmsg, sender->mailbox, sender->context);
-#ifdef IMAP_STORAGE
-		make_file(filename, sizeof(filename), dir, curmsg);
-		strncat(filename, ".txt", sizeof(filename) - strlen(filename) - 1);
-		msg_cfg = ast_config_load(filename, config_flags);
-		if (msg_cfg && msg_cfg == CONFIG_STATUS_FILEINVALID) {
-			msg_id = ast_strdupa(ast_variable_retrieve(msg_cfg, "message", "msg_id"));
-			ast_config_destroy(msg_cfg);
-		}
-#endif
-
-		cmd = SCOPE_CALL_WITH_INT_RESULT(-1, vm_forwardoptions, chan, sender, vmstmp.curdir, curmsg, vmfmts, S_OR(context, "default"), record_gain, &duration, &vmstmp, urgent_str);
-		if (!cmd) {
-			AST_LIST_TRAVERSE_SAFE_BEGIN(&extensions, vmtmp, list) {
-#ifdef IMAP_STORAGE
-				int attach_user_voicemail;
-				char *myserveremail = serveremail;
-
-				/* get destination mailbox */
-				dstvms = get_vm_state_by_mailbox(vmtmp->mailbox, vmtmp->context, 0);
-				if (!dstvms) {
-					dstvms = create_vm_state_from_user(vmtmp);
-				}
-				if (dstvms) {
-					init_mailstream(dstvms, 0);
-					if (!dstvms->mailstream) {
-						ast_log(AST_LOG_ERROR, "IMAP mailstream for %s is NULL\n", vmtmp->mailbox);
-					} else {
-						copy_msg_result = STORE(vmstmp.curdir, vmtmp->mailbox, vmtmp->context, curmsg, chan, vmtmp, fmt, duration, dstvms, urgent_str, msg_id);
-						run_externnotify(vmtmp->context, vmtmp->mailbox, urgent_str);
-					}
-				} else {
-					ast_log(AST_LOG_ERROR, "Could not find state information for mailbox %s\n", vmtmp->mailbox);
-				}
-				if (!ast_strlen_zero(vmtmp->serveremail))
-					myserveremail = vmtmp->serveremail;
-				attach_user_voicemail = ast_test_flag(vmtmp, VM_ATTACH);
-				/* NULL category for IMAP storage */
-				sendmail(myserveremail, vmtmp, todircount, vmtmp->context, vmtmp->mailbox,
-					dstvms->curbox,
-					S_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, NULL),
-					S_COR(ast_channel_caller(chan)->id.name.valid, ast_channel_caller(chan)->id.name.str, NULL),
-					vmstmp.fn, vmstmp.introfn, fmt, duration, attach_user_voicemail, chan,
-					NULL, urgent_str, msg_id);
-#else
-				copy_msg_result = SCOPE_CALL_WITH_INT_RESULT(-1, copy_message, chan, sender, 0, curmsg, duration, vmtmp, fmt, dir, urgent_str, NULL);
-#endif
-				saved_messages++;
-				AST_LIST_REMOVE_CURRENT(list);
-				inprocess_count(vmtmp->mailbox, vmtmp->context, -1);
-				free_user(vmtmp);
-				if (res)
-					break;
-			}
-			AST_LIST_TRAVERSE_SAFE_END;
-			if (saved_messages > 0 && !copy_msg_result) {
-				/* give confirmation that the message was saved */
-				/* commented out since we can't forward batches yet
-				if (saved_messages == 1)
-					res = ast_play_and_wait(chan, "vm-message");
-				else
-					res = ast_play_and_wait(chan, "vm-messages");
-				if (!res)
-					res = ast_play_and_wait(chan, "vm-saved"); */
-				res = ast_play_and_wait(chan, "vm-msgforwarded");
-			}
-#ifndef IMAP_STORAGE
-			else {
-				/* with IMAP, mailbox full warning played by imap_check_limits */
-				res = ast_play_and_wait(chan, "vm-mailboxfull");
-			}
-			/* Restore original message without prepended message if backup exists */
-			make_file(msgfile, sizeof(msgfile), dir, curmsg);
-			strcpy(textfile, msgfile);
-			strcpy(backup, msgfile);
-			strcpy(backup_textfile, msgfile);
-			strncat(textfile, ".txt", sizeof(textfile) - strlen(textfile) - 1);
-			strncat(backup, "-bak", sizeof(backup) - strlen(backup) - 1);
-			strncat(backup_textfile, "-bak.txt", sizeof(backup_textfile) - strlen(backup_textfile) - 1);
-			if (ast_fileexists(backup, NULL, NULL) > 0) {
-				ast_filerename(backup, msgfile, NULL);
-				rename(backup_textfile, textfile);
-			}
-#endif
-		}
-		SCOPE_CALL(-1, DISPOSE, dir, curmsg);
-#ifndef IMAP_STORAGE
-		if (cmd) { /* assuming hangup, cleanup backup file */
-			make_file(msgfile, sizeof(msgfile), dir, curmsg);
-			strcpy(textfile, msgfile);
-			strcpy(backup_textfile, msgfile);
-			strncat(textfile, ".txt", sizeof(textfile) - strlen(textfile) - 1);
-			strncat(backup_textfile, "-bak.txt", sizeof(backup_textfile) - strlen(backup_textfile) - 1);
-			rename(backup_textfile, textfile);
-		}
-#endif
-	}
-
-	/* If anything failed above, we still have this list to free */
-	while ((vmtmp = AST_LIST_REMOVE_HEAD(&extensions, list))) {
-		inprocess_count(vmtmp->mailbox, vmtmp->context, -1);
-		free_user(vmtmp);
-	}
-	SCOPE_EXIT_RTN_VALUE(res ? res : cmd, "Done.  res: %d cmd: %d\n", res, cmd);
-}
-
 static int wait_file2(struct ast_channel *chan, struct vm_state *vms, char *file)
 {
 	int res;
@@ -9537,7 +8991,7 @@ static int open_mailbox(struct vm_state *vms, struct ast_vm_user *vmu, int box)
 	snprintf(vms->vmbox, sizeof(vms->vmbox), "vm-%s", vms->curbox);
 
 	/* Faster to make the directory than to check if it exists. */
-	create_dirpath(vms->curdir, sizeof(vms->curdir), vmu->context, vms->username, vms->curbox);
+	create_dirpath(vms->curdir, sizeof(vms->curdir), vmu->context, vmu->mailbox, vms->curbox);
 
 	/* traverses directory using readdir (or select query for ODBC) */
 	count_msg = COUNT(vmu, vms->curdir);
@@ -10842,7 +10296,7 @@ static int vm_intro(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm
 	char prefile[256];
 
 	/* Notify the user that the temp greeting is set and give them the option to remove it */
-	snprintf(prefile, sizeof(prefile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vms->username);
+	snprintf(prefile, sizeof(prefile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 	if (ast_test_flag(vmu, VM_TEMPGREETWARN)) {
 		RETRIEVE(prefile, -1, vmu->mailbox, vmu->context);
 		if (ast_fileexists(prefile, NULL, NULL) > 0) {
@@ -10972,9 +10426,6 @@ static int vm_instructions_en(struct ast_channel *chan, struct ast_vm_user *vmu,
 						res = ast_play_and_wait(chan, "vm-undelete");
 					}
 				}
-				if (!res) {
-					res = ast_play_and_wait(chan, "vm-toforward");
-				}
 				if (!res) {
 					res = ast_play_and_wait(chan, "vm-savemessage");
 				}
@@ -11065,9 +10516,6 @@ static int vm_instructions_ja(struct ast_channel *chan, struct ast_vm_user *vmu,
 				} else {
 					res = ast_play_and_wait(chan, "vm-undelete");
 				}
-				if (!res) {
-					res = ast_play_and_wait(chan, "vm-toforward");
-				}
 				if (!res) {
 					res = ast_play_and_wait(chan, "vm-savemessage");
 				}
@@ -11149,7 +10597,7 @@ static int vm_newuser_setup(struct ast_channel *chan, struct ast_vm_user *vmu, s
 
 	/* If forcename is set, have the user record their name */
 	if (ast_test_flag(vmu, VM_FORCENAME)) {
-		snprintf(prefile, sizeof(prefile), "%s%s/%s/greet", VM_SPOOL_DIR, vmu->context, vms->username);
+		snprintf(prefile, sizeof(prefile), "%s%s/%s/greet", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 		if (ast_fileexists(prefile, NULL, NULL) < 1) {
 			cmd = play_record_review(chan, "vm-rec-name", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			if (cmd < 0 || cmd == 't' || cmd == '#')
@@ -11159,14 +10607,14 @@ static int vm_newuser_setup(struct ast_channel *chan, struct ast_vm_user *vmu, s
 
 	/* If forcegreetings is set, have the user record their greetings */
 	if (ast_test_flag(vmu, VM_FORCEGREET)) {
-		snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, vms->username);
+		snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 		if (ast_fileexists(prefile, NULL, NULL) < 1) {
 			cmd = play_record_review(chan, "vm-rec-unv", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			if (cmd < 0 || cmd == 't' || cmd == '#')
 				return cmd;
 		}
 
-		snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, vms->username);
+		snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 		if (ast_fileexists(prefile, NULL, NULL) < 1) {
 			cmd = play_record_review(chan, "vm-rec-busy", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			if (cmd < 0 || cmd == 't' || cmd == '#')
@@ -11190,7 +10638,7 @@ static int vm_newuser_setup(struct ast_channel *chan, struct ast_vm_user *vmu, s
 			return cmd;
 		cmd = check_password(vmu, newpassword); /* perform password validation */
 		if (cmd != 0) {
-			ast_log(AST_LOG_NOTICE, "Invalid password for user %s (%s)\n", vms->username, newpassword);
+			ast_log(AST_LOG_NOTICE, "Invalid password for user %s (%s)\n", vmu->mailbox, newpassword);
 			cmd = ast_play_and_wait(chan, vm_invalid_password);
 		} else {
 			newpassword2[1] = '\0';
@@ -11204,7 +10652,7 @@ static int vm_newuser_setup(struct ast_channel *chan, struct ast_vm_user *vmu, s
 				return cmd;
 			if (!strcmp(newpassword, newpassword2))
 				break;
-			ast_log(AST_LOG_NOTICE, "Password mismatch for user %s (%s != %s)\n", vms->username, newpassword, newpassword2);
+			ast_log(AST_LOG_NOTICE, "Password mismatch for user %s (%s != %s)\n", vmu->mailbox, newpassword, newpassword2);
 			cmd = ast_play_and_wait(chan, vm_mismatch);
 		}
 		if (++tries == 3)
@@ -11218,7 +10666,7 @@ static int vm_newuser_setup(struct ast_channel *chan, struct ast_vm_user *vmu, s
 	if ((pwdchange & PWDCHANGE_EXTERNAL) && !ast_strlen_zero(ext_pass_cmd))
 		vm_change_password_shell(vmu, newpassword);
 
-	ast_debug(1, "User %s set password to %s of length %d\n", vms->username, newpassword, (int) strlen(newpassword));
+	ast_debug(1, "User %s set password to %s of length %d\n", vmu->mailbox, newpassword, (int) strlen(newpassword));
 	cmd = ast_play_and_wait(chan, vm_passchanged);
 
 	return cmd;
@@ -11250,15 +10698,15 @@ static int vm_options(struct ast_channel *chan, struct ast_vm_user *vmu, struct
 			retries = 0;
 		switch (cmd) {
 		case '1': /* Record your unavailable message */
-			snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, vms->username);
+			snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 			cmd = SCOPE_CALL_WITH_INT_RESULT(-1, play_record_review, chan, "vm-rec-unv", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			break;
 		case '2':  /* Record your busy message */
-			snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, vms->username);
+			snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 			cmd = SCOPE_CALL_WITH_INT_RESULT(-1, play_record_review, chan, "vm-rec-busy", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			break;
 		case '3': /* Record greeting */
-			snprintf(prefile, sizeof(prefile), "%s%s/%s/greet", VM_SPOOL_DIR, vmu->context, vms->username);
+			snprintf(prefile, sizeof(prefile), "%s%s/%s/greet", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 			cmd = SCOPE_CALL_WITH_INT_RESULT(-1, play_record_review, chan, "vm-rec-name", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			break;
 		case '4':  /* manage the temporary greeting */
@@ -11282,7 +10730,7 @@ static int vm_options(struct ast_channel *chan, struct ast_vm_user *vmu, struct
 			}
 			cmd = check_password(vmu, newpassword); /* perform password validation */
 			if (cmd != 0) {
-				ast_log(AST_LOG_NOTICE, "Invalid password for user %s (%s)\n", vms->username, newpassword);
+				ast_log(AST_LOG_NOTICE, "Invalid password for user %s (%s)\n", vmu->mailbox, newpassword);
 				cmd = ast_play_and_wait(chan, vm_invalid_password);
 				if (!cmd) {
 					cmd = ast_play_and_wait(chan, vm_pls_try_again);
@@ -11302,7 +10750,7 @@ static int vm_options(struct ast_channel *chan, struct ast_vm_user *vmu, struct
 				}
 			}
 			if (strcmp(newpassword, newpassword2)) {
-				ast_log(AST_LOG_NOTICE, "Password mismatch for user %s (%s != %s)\n", vms->username, newpassword, newpassword2);
+				ast_log(AST_LOG_NOTICE, "Password mismatch for user %s (%s != %s)\n", vmu->mailbox, newpassword, newpassword2);
 				cmd = ast_play_and_wait(chan, vm_mismatch);
 				if (!cmd) {
 					cmd = ast_play_and_wait(chan, vm_pls_try_again);
@@ -11318,7 +10766,7 @@ static int vm_options(struct ast_channel *chan, struct ast_vm_user *vmu, struct
 			}
 
 			ast_debug(1, "User %s set password to %s of length %d\n",
-				vms->username, newpassword, (int) strlen(newpassword));
+				vmu->mailbox, newpassword, (int) strlen(newpassword));
 			cmd = ast_play_and_wait(chan, vm_passchanged);
 			break;
 		case '*':
@@ -11326,7 +10774,7 @@ static int vm_options(struct ast_channel *chan, struct ast_vm_user *vmu, struct
 			break;
 		default:
 			cmd = 0;
-			snprintf(prefile, sizeof(prefile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vms->username);
+			snprintf(prefile, sizeof(prefile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 			SCOPE_CALL(-1, RETRIEVE, prefile, -1, vmu->mailbox, vmu->context);
 			if (ast_fileexists(prefile, NULL, NULL)) {
 				cmd = ast_play_and_wait(chan, "vm-tmpexists");
@@ -11388,7 +10836,7 @@ static int vm_tempgreeting(struct ast_channel *chan, struct ast_vm_user *vmu, st
 	}
 
 	ast_test_suite_event_notify("TEMPGREETING", "Message: entering temp greeting options");
-	snprintf(prefile, sizeof(prefile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vms->username);
+	snprintf(prefile, sizeof(prefile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 	while ((cmd >= 0) && (cmd != 't')) {
 		if (cmd)
 			retries = 0;
@@ -12710,37 +12158,6 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 			vms.repeats = 0;
 			while ((cmd > -1) && (cmd != 't') && (cmd != '#')) {
 				switch (cmd) {
-				case '1': /* Reply */
-					if (vms.lastmsg > -1 && !vms.starting) {
-						cmd = advanced_options(chan, vmu, &vms, vms.curmsg, 1, record_gain);
-						if (cmd == ERROR_LOCK_PATH || cmd == OPERATOR_EXIT) {
-							res = cmd;
-							ast_trace(-1, "advanced options: %d\n", cmd);
-							goto out;
-						}
-					} else {
-						cmd = ast_play_and_wait(chan, "vm-sorry");
-					}
-					cmd = 't';
-					break;
-				case '2': /* Callback */
-					if (!vms.starting)
-						ast_verb(3, "Callback Requested\n");
-					if (!ast_strlen_zero(vmu->callback) && vms.lastmsg > -1 && !vms.starting) {
-						cmd = advanced_options(chan, vmu, &vms, vms.curmsg, 2, record_gain);
-						ast_trace(-1, "advanced options: %d\n", cmd);
-						if (cmd == 9) {
-							silentexit = 1;
-							goto out;
-						} else if (cmd == ERROR_LOCK_PATH) {
-							res = cmd;
-							goto out;
-						}
-					} else {
-						cmd = ast_play_and_wait(chan, "vm-sorry");
-					}
-					cmd = 't';
-					break;
 				case '3': /* Envelope */
 					if (vms.lastmsg > -1 && !vms.starting) {
 						ast_safe_sleep(chan, 500);
@@ -12755,34 +12172,6 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 					}
 					cmd = 't';
 					break;
-				case '4': /* Dialout */
-					if (!ast_strlen_zero(vmu->dialout)) {
-						cmd = dialout(chan, vmu, NULL, vmu->dialout);
-						if (cmd == 9) {
-							silentexit = 1;
-							ast_trace(-1, "dialout: %d\n", cmd);
-							goto out;
-						}
-					} else {
-						cmd = ast_play_and_wait(chan, "vm-sorry");
-					}
-					cmd = 't';
-					break;
-
-				case '5': /* Leave VoiceMail */
-					if (ast_test_flag(vmu, VM_SVMAIL)) {
-						cmd = SCOPE_CALL_WITH_INT_RESULT(-1, forward_message, chan, context, &vms, vmu, vmfmts, 1, record_gain, 0);
-						if (cmd == ERROR_LOCK_PATH || cmd == OPERATOR_EXIT) {
-							res = cmd;
-							ast_trace(-1, "forward message: %d\n", cmd);
-							goto out;
-						}
-					} else {
-						cmd = ast_play_and_wait(chan, "vm-sorry");
-					}
-					cmd = 't';
-					break;
-
 				case '*': /* Return to main menu */
 					cmd = 't';
 					break;
@@ -12790,21 +12179,9 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 				default:
 					ast_safe_sleep(chan, 500);
 					cmd = 0;
-					if (!vms.starting) {
-						cmd = ast_play_and_wait(chan, "vm-toreply");
-					}
-					if (!ast_strlen_zero(vmu->callback) && !vms.starting && !cmd) {
-						cmd = ast_play_and_wait(chan, "vm-tocallback");
-					}
 					if (!cmd && !vms.starting) {
 						cmd = ast_play_and_wait(chan, "vm-tohearenv");
 					}
-					if (!ast_strlen_zero(vmu->dialout) && !cmd) {
-						cmd = ast_play_and_wait(chan, "vm-tomakecall");
-					}
-					if (ast_test_flag(vmu, VM_SVMAIL) && !cmd) {
-						cmd = ast_play_and_wait(chan, "vm-leavemsg");
-					}
 					if (!cmd) {
 						cmd = ast_play_and_wait(chan, "vm-starmain");
 					}
@@ -12967,42 +12344,6 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 #endif
 			break;
 
-		case '8': /* Forward the current message */
-			if (vms.lastmsg > -1) {
-				cmd = SCOPE_CALL_WITH_INT_RESULT(-1, forward_message, chan, context, &vms, vmu, vmfmts, 0, record_gain, in_urgent);
-				if (cmd == ERROR_LOCK_PATH) {
-					res = cmd;
-					ast_trace(-1, "forward message: %d\n", res);
-					goto out;
-				}
-			} else {
-				/* Check if we were listening to urgent
-				   messages.  If so, go to regular new messages
-				   instead of saying "no more messages"
-				*/
-				if (in_urgent == 1 && vms.newmessages > 0) {
-					/* Check for new messages */
-					in_urgent = 0;
-					res = SCOPE_CALL_WITH_INT_RESULT(-1, close_mailbox, &vms, vmu);
-					if (res == ERROR_LOCK_PATH) {
-						ast_trace(-1, "close mailbox: %d\n", res);
-						goto out;
-					}
-					res = SCOPE_CALL_WITH_INT_RESULT(-1, open_mailbox, &vms, vmu, NEW_FOLDER);
-					if (res < 0) {
-						ast_trace(-1, "open mailbox: %d\n", res);
-						goto out;
-					}
-					ast_debug(1, "No more urgent messages, opened INBOX and got %d new messages\n", vms.lastmsg + 1);
-					vms.curmsg = -1;
-					if (vms.lastmsg < 0) {
-						cmd = ast_play_and_wait(chan, "vm-nomore");
-					}
-				} else {
-					cmd = ast_play_and_wait(chan, "vm-nomore");
-				}
-			}
-			break;
 		case '9': /* Save message to folder */
 			ast_test_suite_event_notify("SAVEMSG", "Message: saving message %d\r\nVoicemail: %d", vms.curmsg, vms.curmsg);
 			if (vms.curmsg < 0 || vms.curmsg > vms.lastmsg) {
@@ -13118,6 +12459,7 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 				cmd = 0;
 			break;
 		case '0': /* Mailbox options */
+			ast_log(LOG_DEBUG, "setting options for '%s'", vmu->mailbox);
 			cmd = SCOPE_CALL_WITH_INT_RESULT(-1, vm_options,chan, vmu, &vms, vmfmts, record_gain);
 			if (useadsi)
 				adsi_status(chan, &vms);
@@ -13166,7 +12508,7 @@ out:
 		int new = 0, old = 0, urgent = 0;
 		snprintf(ext_context, sizeof(ext_context), "%s@%s", vms.username, vmu->context);
 		/* Urgent flag not passwd to externnotify here */
-		run_externnotify(vmu->context, vmu->mailbox, NULL);
+		run_externnotify(vmu->context, vmu->mailbox, NULL, vmu->dialed_num);
 		ast_app_inboxcount2(ext_context, &urgent, &new, &old);
 		queue_mwi_event(ast_channel_uniqueid(chan), ext_context, urgent, new, old);
 	}
@@ -14006,7 +13348,6 @@ static int poll_subscribed_mailbox(struct ast_mwi_state *mwi_state, void *data)
 
 	if (urgent != mwi_state->urgent_msgs || new != mwi_state->new_msgs || old != mwi_state->old_msgs) {
 		queue_mwi_event(NULL, mwi_state->uniqueid, urgent, new, old);
-		run_externnotify(NULL, mwi_state->uniqueid, NULL);
 	}
 
 	return 0;
@@ -17345,7 +16686,7 @@ static void notify_new_state(struct ast_vm_user *vmu)
 	char ext_context[1024];
 
 	snprintf(ext_context, sizeof(ext_context), "%s@%s", vmu->mailbox, vmu->context);
-	run_externnotify(vmu->context, vmu->mailbox, NULL);
+	run_externnotify(vmu->context, vmu->mailbox, NULL, vmu->dialed_num);
 	ast_app_inboxcount2(ext_context, &urgent, &new, &old);
 	queue_mwi_event(NULL, ext_context, urgent, new, old);
 }
