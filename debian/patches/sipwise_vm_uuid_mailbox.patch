From: Sipwise Development Team <support@sipwise.com>
Date: Mon, 4 Nov 2024 15:37:29 +0100
Subject: sipwise_vm_uuid_mailbox

---
 apps/app_voicemail.c | 145 +++++++++++++++++++++++++++++++--------------------
 1 file changed, 89 insertions(+), 56 deletions(-)

diff --git a/apps/app_voicemail.c b/apps/app_voicemail.c
index a9f4156..29fd37f 100644
--- a/apps/app_voicemail.c
+++ b/apps/app_voicemail.c
@@ -58,14 +58,14 @@
 	<member name="FILE_STORAGE" displayname="Storage of Voicemail using filesystem">
 		<conflict>ODBC_STORAGE</conflict>
 		<conflict>IMAP_STORAGE</conflict>
-		<defaultenabled>yes</defaultenabled>
+		<defaultenabled>no</defaultenabled>
 		<support_level>core</support_level>
 	</member>
 	<member name="ODBC_STORAGE" displayname="Storage of Voicemail using ODBC">
 		<depend>generic_odbc</depend>
 		<conflict>IMAP_STORAGE</conflict>
 		<conflict>FILE_STORAGE</conflict>
-		<defaultenabled>no</defaultenabled>
+		<defaultenabled>yes</defaultenabled>
 		<support_level>core</support_level>
 	</member>
 	<member name="IMAP_STORAGE" displayname="Storage of Voicemail using IMAP4">
@@ -841,7 +841,8 @@ and vm-Old are spelled plural, to make them sound more as folder name than an ad
  * Use ast_vm_user_destroy() to free one of these structures. */
 struct ast_vm_user {
 	char context[MAX_VM_CONTEXT_LEN];/*!< Voicemail context */
-	char mailbox[MAX_VM_MBOX_ID_LEN];/*!< Mailbox id, unique within vm context */
+	char mailbox[MAX_VM_MBOX_ID_LEN]; /*!< granig: the mailbox uuid */
+	char dialed_num[MAX_VM_MBOX_ID_LEN]; /*!< granig: the mailbox number */
 	char password[80];               /*!< Secret pin code, numbers only */
 	char fullname[80];               /*!< Full name, for directory app */
 	char *email;                     /*!< E-mail address */
@@ -1663,6 +1664,12 @@ static void apply_options_full(struct ast_vm_user *retval, struct ast_variable *
 		} else if (!strcasecmp(var->name, "emailbody")) {
 			ast_free(retval->emailbody);
 			retval->emailbody = ast_strdup(substitute_escapes(var->value));
+		} else if (!strcasecmp(var->name, "customer_id")) { /* granig: use uuid instead of number */
+			ast_copy_string(retval->mailbox, var->value, sizeof(retval->mailbox));
+			// ast_log (LOG_DEBUG,"setting mailbox to '%s'\n", var->value);
+		} else if (!strcasecmp(var->name, "mailbox")) { /* granig: but save number for announcement */
+			ast_copy_string(retval->dialed_num, var->value, sizeof(retval->dialed_num));
+			// ast_log (LOG_DEBUG,"setting dialed_num to '%s'\n", var->value);
 #ifdef IMAP_STORAGE
 		} else if (!strcasecmp(var->name, "imapuser")) {
 			ast_copy_string(retval->imapuser, var->value, sizeof(retval->imapuser));
@@ -1745,6 +1752,7 @@ static struct ast_vm_user *find_user_realtime(struct ast_vm_user *ivm, const cha
 			var = ast_load_realtime("voicemail", "mailbox", mailbox, "context", context, SENTINEL);
 		}
 		if (var) {
+			// ast_log (LOG_DEBUG,"call apply_options_full\n");
 			apply_options_full(retval, var);
 			ast_variables_destroy(var);
 		} else {
@@ -1800,6 +1808,7 @@ static struct ast_vm_user *find_user(struct ast_vm_user *ivm, const char *contex
 	}
 	AST_LIST_UNLOCK(&users);
 	if (!vmu) {
+		ast_log(LOG_DEBUG,"call find_user_realtime for '%s@%s'\n", mailbox, context);
 		vmu = find_user_realtime(ivm, context, mailbox);
 	}
 	if (!vmu && !ast_strlen_zero(aliasescontext)) {
@@ -3149,7 +3158,7 @@ static int open_mailbox(struct vm_state *vms, struct ast_vm_user *vmu, int box)
 		return -1;
 	}
 
-	create_dirpath(vms->curdir, sizeof(vms->curdir), vmu->context, vms->username, vms->curbox);
+	create_dirpath(vms->curdir, sizeof(vms->curdir), vmu->context, vms->mailbox, vms->curbox);
 
 	/* Check Quota */
 	if  (box == 0)  {
@@ -4873,7 +4882,8 @@ static void prep_email_sub_vars(struct ast_channel *ast, struct ast_vm_user *vmu
 	snprintf(num, sizeof(num), "%d", msgnum);
 	pbx_builtin_setvar_helper(ast, "VM_MSGNUM", num);
 	pbx_builtin_setvar_helper(ast, "VM_CONTEXT", context);
-	pbx_builtin_setvar_helper(ast, "VM_MAILBOX", mailbox);
+	pbx_builtin_setvar_helper(ast, "VM_MAILBOX", vmu->dialed_num);
+	pbx_builtin_setvar_helper(ast, "VM_UUID", vmu->mailbox);
 	pbx_builtin_setvar_helper(ast, "VM_CALLERID", (!ast_strlen_zero(cidname) || !ast_strlen_zero(cidnum)) ?
 		ast_callerid_merge(callerid, sizeof(callerid), cidname, cidnum, NULL) : "an unknown caller");
 	pbx_builtin_setvar_helper(ast, "VM_CIDNAME", (!ast_strlen_zero(cidname) ? cidname : "an unknown caller"));
@@ -5697,7 +5707,7 @@ static int get_date(char *s, int len)
 	return ast_strftime(s, len, "%a %b %e %r UTC %Y", &tm);
 }
 
-static int invent_message(struct ast_channel *chan, char *context, char *ext, int busy, char *ecodes)
+static int invent_message(struct ast_channel *chan, char *context, char *ext, char *dialed_num, int busy, char *ecodes)
 {
 	int res;
 	char fn[PATH_MAX];
@@ -5720,12 +5730,18 @@ static int invent_message(struct ast_channel *chan, char *context, char *ext, in
 	} else {
 		/* Dispose just in case */
 		DISPOSE(fn, -1);
+		/*
 		res = ast_stream_and_wait(chan, "vm-theperson", ecodes);
-		if (res)
+		if (res) {
+			ast_log(LOG_WARNING, "failed to stream/wait vm-theperson\n");
 			return res;
-		res = ast_say_digit_str(chan, ext, ecodes, ast_channel_language(chan));
-		if (res)
+		}
+		*/
+		res = ast_say_digit_str(chan, dialed_num, ecodes, ast_channel_language(chan));
+		if (res) {
+			ast_log(LOG_WARNING, "failed to stream/wait '%s'\n", dialed_num);
 			return res;
+		}
 	}
 	res = ast_stream_and_wait(chan, busy ? "vm-isonphone" : "vm-isunavail", ecodes);
 	return res;
@@ -5769,6 +5785,7 @@ static int count_messages_in_folder(struct odbc_obj *odbc, const char *context,
 	}
 
 	*messages = atoi(rowdata);
+	ast_log(LOG_DEBUG, "inboxcount/%s: %d\n", context, *messages);
 	SQLFreeHandle(SQL_HANDLE_STMT, stmt);
 
 	return 0;
@@ -6195,10 +6212,11 @@ static int inboxcount(const char *mailbox, int *newmsgs, int *oldmsgs)
 	return res;
 }
 
-static void run_externnotify(char *context, char *extension, const char *flag)
+static void run_externnotify(char *context, char *extension, const char *flag, char *dialed_num)
 {
 	char arguments[255];
 	char ext_context[256] = "";
+	char number[256] = "";
 	int newvoicemails = 0, oldvoicemails = 0, urgentvoicemails = 0;
 	struct ast_smdi_mwi_message *mwi_msg;
 
@@ -6207,6 +6225,9 @@ static void run_externnotify(char *context, char *extension, const char *flag)
 	else
 		ast_copy_string(ext_context, extension, sizeof(ext_context));
 
+	if (!ast_strlen_zero(dialed_num))
+		ast_copy_string(number, dialed_num, sizeof(number));
+
 	if (smdi_iface) {
 		if (ast_app_has_voicemail(ext_context, NULL))
 			ast_smdi_mwi_set(smdi_iface, extension);
@@ -6227,12 +6248,15 @@ static void run_externnotify(char *context, char *extension, const char *flag)
 	}
 
 	if (!ast_strlen_zero(externnotify)) {
+		ast_log(LOG_DEBUG, "Perform inboxcount on context '%s' and number '%s'\n", ext_context, number);
 		if (inboxcount2(ext_context, &urgentvoicemails, &newvoicemails, &oldvoicemails)) {
 			ast_log(AST_LOG_ERROR, "Problem in calculating number of voicemail messages available for extension %s\n", extension);
+		} else if (ast_strlen_zero(number) || !strcmp(extension, number)) {
+			ast_log(AST_LOG_WARNING, "Missing user number to run externnotify on context '%s'\n", ext_context);
 		} else {
 			snprintf(arguments, sizeof(arguments), "%s %s %s %d %d %d &",
 				externnotify, S_OR(context, "\"\""),
-				extension, newvoicemails,
+				number, newvoicemails,
 				oldvoicemails, urgentvoicemails);
 			ast_debug(1, "Executing %s\n", arguments);
 			ast_safe_system(arguments);
@@ -6650,7 +6674,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 
 	/* Setup pre-file if appropriate */
 	if (strcmp(vmu->context, "default"))
-		snprintf(ext_context, sizeof(ext_context), "%s@%s", ext, vmu->context);
+		snprintf(ext_context, sizeof(ext_context), "%s@%s", vmu->mailbox, vmu->context);
 	else
 		ast_copy_string(ext_context, vmu->mailbox, sizeof(ext_context));
 
@@ -6660,16 +6684,16 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 	   Depending on the flag set in options.
 	*/
 	if (ast_test_flag(options, OPT_BUSY_GREETING)) {
-		snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, ext);
+		snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 	} else if (ast_test_flag(options, OPT_UNAVAIL_GREETING)) {
-		snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, ext);
+		snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 	}
 	/* Set the path to the tmpfile as
 		VM_SPOOL_DIR/context/ext/temp
 	   and attempt to create the folder structure.
 	*/
-	snprintf(tempfile, sizeof(tempfile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, ext);
-	if ((res = create_dirpath(tmpdir, sizeof(tmpdir), vmu->context, ext, "tmp"))) {
+	snprintf(tempfile, sizeof(tempfile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
+	if ((res = create_dirpath(tmpdir, sizeof(tmpdir), vmu->context, vmu->mailbox, "tmp"))) {
 		ast_log(AST_LOG_WARNING, "Failed to make directory (%s)\n", tempfile);
 		free_user(vmu);
 		ast_free(tmp);
@@ -6682,7 +6706,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 	DISPOSE(tempfile, -1);
 	/* It's easier just to try to make it than to check for its existence */
 #ifndef IMAP_STORAGE
-	create_dirpath(dir, sizeof(dir), vmu->context, ext, "INBOX");
+	create_dirpath(dir, sizeof(dir), vmu->context, vmu->mailbox, "INBOX");
 #else
 	snprintf(dir, sizeof(dir), "%simap", VM_SPOOL_DIR);
 	if (mkdir(dir, VOICEMAIL_DIR_MODE) && errno != EEXIST) {
@@ -6743,7 +6767,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 #ifdef ODBC_STORAGE
 		int success =
 #endif
-			RETRIEVE(prefile, -1, ext, context);
+			RETRIEVE(prefile, -1, vmu->mailbox, context);
 		if (ast_fileexists(prefile, NULL, NULL) > 0) {
 			if (ast_streamfile(chan, prefile, ast_channel_language(chan)) > -1) {
 				/* We know we have a greeting at this point, so squelch the instructions
@@ -6762,7 +6786,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 #endif
 		} else {
 			ast_debug(1, "%s doesn't exist, doing what we can\n", prefile);
-			res = invent_message(chan, vmu->context, ext, ast_test_flag(options, OPT_BUSY_GREETING), ecodes);
+			res = invent_message(chan, vmu->context, vmu->mailbox, vmu->dialed_num, ast_test_flag(options, OPT_BUSY_GREETING), ecodes);
 		}
 		DISPOSE(prefile, -1);
 		if (res < 0) {
@@ -6865,7 +6889,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 			ast_free(tmp);
 			return -1;
 		}
-		if (!(vms = get_vm_state_by_mailbox(ext, context, 0))) {
+		if (!(vms = get_vm_state_by_mailbox(vmu->mailbox, context, 0))) {
 		/* It is possible under certain circumstances that inboxcount did not
 		 * create a vm_state when it was needed. This is a catchall which will
 		 * rarely be used.
@@ -6933,7 +6957,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 				S_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, NULL),
 				"Unknown");
 			ast_store_realtime("voicemail_data",
-				"origmailbox", ext,
+				"origmailbox", vmu->mailbox,
 				"context", ast_channel_context(chan),
 				"macrocontext", ast_channel_macrocontext(chan),
 				"exten", ast_channel_exten(chan),
@@ -6973,7 +6997,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 				"origtime=%ld\n"
 				"category=%s\n"
 				"msg_id=%s\n",
-				ext,
+				vmu->mailbox,
 				ast_channel_context(chan),
 				ast_channel_macrocontext(chan),
 				ast_channel_exten(chan),
@@ -7001,7 +7025,7 @@ static int leave_voicemail(struct ast_channel *chan, char *ext, struct leave_vm_
 		   leaving the message. So we update the directory where we want this
 		   message to go. */
 		if (!strcmp(flag, "Urgent")) {
-			create_dirpath(dir, sizeof(dir), vmu->context, ext, "Urgent");
+			create_dirpath(dir, sizeof(dir), vmu->context, vmu->mailbox, "Urgent");
 		}
 
 		if (txt) {
@@ -7233,7 +7257,7 @@ static int save_to_folder(struct ast_vm_user *vmu, struct vm_state *vms, int msg
 	return res;
 #else
 	char *dir = vms->curdir;
-	char *username = vms->username;
+	char *username = vmu->mailbox;
 	char *context = vmu->context;
 	char sfn[PATH_MAX];
 	char dfn[PATH_MAX];
@@ -8196,7 +8220,7 @@ static int notify_new_message(struct ast_channel *chan, struct ast_vm_user *vmu,
 		ast_app_inboxcount2(ext_context, &urgentmsgs, &newmsgs, &oldmsgs);
 
 	queue_mwi_event(ast_channel_uniqueid(chan), ext_context, urgentmsgs, newmsgs, oldmsgs);
-	run_externnotify(vmu->context, vmu->mailbox, flag);
+	run_externnotify(vmu->context, vmu->mailbox, flag, vmu->dialed_num);
 
 #ifdef IMAP_STORAGE
 	vm_delete(fn);  /* Delete the file, but not the IMAP message */
@@ -8499,7 +8523,7 @@ static int forward_message(struct ast_channel *chan, char *context, struct vm_st
 						ast_log(AST_LOG_ERROR, "IMAP mailstream for %s is NULL\n", vmtmp->mailbox);
 					} else {
 						copy_msg_result = STORE(vmstmp.curdir, vmtmp->mailbox, vmtmp->context, curmsg, chan, vmtmp, fmt, duration, dstvms, urgent_str, msg_id);
-						run_externnotify(vmtmp->context, vmtmp->mailbox, urgent_str);
+						run_externnotify(vmtmp->context, vmtmp->mailbox, urgent_str, vmtmp->dialed_num);
 					}
 				} else {
 					ast_log(AST_LOG_ERROR, "Could not find state information for mailbox %s\n", vmtmp->mailbox);
@@ -9078,7 +9102,7 @@ static int open_mailbox(struct vm_state *vms, struct ast_vm_user *vmu, int box)
 	snprintf(vms->vmbox, sizeof(vms->vmbox), "vm-%s", vms->curbox);
 
 	/* Faster to make the directory than to check if it exists. */
-	create_dirpath(vms->curdir, sizeof(vms->curdir), vmu->context, vms->username, vms->curbox);
+	create_dirpath(vms->curdir, sizeof(vms->curdir), vmu->context, vmu->mailbox, vms->curbox);
 
 	/* traverses directory using readdir (or select query for ODBC) */
 	count_msg = count_messages(vmu, vms->curdir);
@@ -10378,7 +10402,7 @@ static int vm_intro(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm
 	char prefile[256];
 
 	/* Notify the user that the temp greeting is set and give them the option to remove it */
-	snprintf(prefile, sizeof(prefile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vms->username);
+	snprintf(prefile, sizeof(prefile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 	if (ast_test_flag(vmu, VM_TEMPGREETWARN)) {
 		RETRIEVE(prefile, -1, vmu->mailbox, vmu->context);
 		if (ast_fileexists(prefile, NULL, NULL) > 0) {
@@ -10508,9 +10532,11 @@ static int vm_instructions_en(struct ast_channel *chan, struct ast_vm_user *vmu,
 						res = ast_play_and_wait(chan, "vm-undelete");
 					}
 				}
+				/*
 				if (!res) {
 					res = ast_play_and_wait(chan, "vm-toforward");
 				}
+				*/
 				if (!res) {
 					res = ast_play_and_wait(chan, "vm-savemessage");
 				}
@@ -10601,9 +10627,11 @@ static int vm_instructions_ja(struct ast_channel *chan, struct ast_vm_user *vmu,
 				} else {
 					res = ast_play_and_wait(chan, "vm-undelete");
 				}
+				/*
 				if (!res) {
 					res = ast_play_and_wait(chan, "vm-toforward");
 				}
+				*/
 				if (!res) {
 					res = ast_play_and_wait(chan, "vm-savemessage");
 				}
@@ -10685,7 +10713,7 @@ static int vm_newuser_setup(struct ast_channel *chan, struct ast_vm_user *vmu, s
 
 	/* If forcename is set, have the user record their name */
 	if (ast_test_flag(vmu, VM_FORCENAME)) {
-		snprintf(prefile, sizeof(prefile), "%s%s/%s/greet", VM_SPOOL_DIR, vmu->context, vms->username);
+		snprintf(prefile, sizeof(prefile), "%s%s/%s/greet", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 		if (ast_fileexists(prefile, NULL, NULL) < 1) {
 			cmd = play_record_review(chan, "vm-rec-name", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			if (cmd < 0 || cmd == 't' || cmd == '#')
@@ -10695,14 +10723,14 @@ static int vm_newuser_setup(struct ast_channel *chan, struct ast_vm_user *vmu, s
 
 	/* If forcegreetings is set, have the user record their greetings */
 	if (ast_test_flag(vmu, VM_FORCEGREET)) {
-		snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, vms->username);
+		snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 		if (ast_fileexists(prefile, NULL, NULL) < 1) {
 			cmd = play_record_review(chan, "vm-rec-unv", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			if (cmd < 0 || cmd == 't' || cmd == '#')
 				return cmd;
 		}
 
-		snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, vms->username);
+		snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 		if (ast_fileexists(prefile, NULL, NULL) < 1) {
 			cmd = play_record_review(chan, "vm-rec-busy", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			if (cmd < 0 || cmd == 't' || cmd == '#')
@@ -10726,7 +10754,7 @@ static int vm_newuser_setup(struct ast_channel *chan, struct ast_vm_user *vmu, s
 			return cmd;
 		cmd = check_password(vmu, newpassword); /* perform password validation */
 		if (cmd != 0) {
-			ast_log(AST_LOG_NOTICE, "Invalid password for user %s (%s)\n", vms->username, newpassword);
+			ast_log(AST_LOG_NOTICE, "Invalid password for user %s (%s)\n", vmu->mailbox, newpassword);
 			cmd = ast_play_and_wait(chan, vm_invalid_password);
 		} else {
 			newpassword2[1] = '\0';
@@ -10740,7 +10768,7 @@ static int vm_newuser_setup(struct ast_channel *chan, struct ast_vm_user *vmu, s
 				return cmd;
 			if (!strcmp(newpassword, newpassword2))
 				break;
-			ast_log(AST_LOG_NOTICE, "Password mismatch for user %s (%s != %s)\n", vms->username, newpassword, newpassword2);
+			ast_log(AST_LOG_NOTICE, "Password mismatch for user %s (%s != %s)\n", vmu->mailbox, newpassword, newpassword2);
 			cmd = ast_play_and_wait(chan, vm_mismatch);
 		}
 		if (++tries == 3)
@@ -10754,7 +10782,7 @@ static int vm_newuser_setup(struct ast_channel *chan, struct ast_vm_user *vmu, s
 	if ((pwdchange & PWDCHANGE_EXTERNAL) && !ast_strlen_zero(ext_pass_cmd))
 		vm_change_password_shell(vmu, newpassword);
 
-	ast_debug(1, "User %s set password to %s of length %d\n", vms->username, newpassword, (int) strlen(newpassword));
+	ast_debug(1, "User %s set password to %s of length %d\n", vmu->mailbox, newpassword, (int) strlen(newpassword));
 	cmd = ast_play_and_wait(chan, vm_passchanged);
 
 	return cmd;
@@ -10785,15 +10813,15 @@ static int vm_options(struct ast_channel *chan, struct ast_vm_user *vmu, struct
 			retries = 0;
 		switch (cmd) {
 		case '1': /* Record your unavailable message */
-			snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, vms->username);
+			snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 			cmd = play_record_review(chan, "vm-rec-unv", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			break;
 		case '2':  /* Record your busy message */
-			snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, vms->username);
+			snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 			cmd = play_record_review(chan, "vm-rec-busy", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			break;
 		case '3': /* Record greeting */
-			snprintf(prefile, sizeof(prefile), "%s%s/%s/greet", VM_SPOOL_DIR, vmu->context, vms->username);
+			snprintf(prefile, sizeof(prefile), "%s%s/%s/greet", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 			cmd = play_record_review(chan, "vm-rec-name", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			break;
 		case '4':  /* manage the temporary greeting */
@@ -10817,7 +10845,7 @@ static int vm_options(struct ast_channel *chan, struct ast_vm_user *vmu, struct
 			}
 			cmd = check_password(vmu, newpassword); /* perform password validation */
 			if (cmd != 0) {
-				ast_log(AST_LOG_NOTICE, "Invalid password for user %s (%s)\n", vms->username, newpassword);
+				ast_log(AST_LOG_NOTICE, "Invalid password for user %s (%s)\n", vmu->mailbox, newpassword);
 				cmd = ast_play_and_wait(chan, vm_invalid_password);
 				if (!cmd) {
 					cmd = ast_play_and_wait(chan, vm_pls_try_again);
@@ -10837,7 +10865,7 @@ static int vm_options(struct ast_channel *chan, struct ast_vm_user *vmu, struct
 				}
 			}
 			if (strcmp(newpassword, newpassword2)) {
-				ast_log(AST_LOG_NOTICE, "Password mismatch for user %s (%s != %s)\n", vms->username, newpassword, newpassword2);
+				ast_log(AST_LOG_NOTICE, "Password mismatch for user %s (%s != %s)\n", vmu->mailbox, newpassword, newpassword2);
 				cmd = ast_play_and_wait(chan, vm_mismatch);
 				if (!cmd) {
 					cmd = ast_play_and_wait(chan, vm_pls_try_again);
@@ -10853,7 +10881,7 @@ static int vm_options(struct ast_channel *chan, struct ast_vm_user *vmu, struct
 			}
 
 			ast_debug(1, "User %s set password to %s of length %d\n",
-				vms->username, newpassword, (int) strlen(newpassword));
+				vmu->mailbox, newpassword, (int) strlen(newpassword));
 			cmd = ast_play_and_wait(chan, vm_passchanged);
 			break;
 		case '*':
@@ -10861,7 +10889,7 @@ static int vm_options(struct ast_channel *chan, struct ast_vm_user *vmu, struct
 			break;
 		default:
 			cmd = 0;
-			snprintf(prefile, sizeof(prefile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vms->username);
+			snprintf(prefile, sizeof(prefile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 			RETRIEVE(prefile, -1, vmu->mailbox, vmu->context);
 			if (ast_fileexists(prefile, NULL, NULL)) {
 				cmd = ast_play_and_wait(chan, "vm-tmpexists");
@@ -10923,7 +10951,7 @@ static int vm_tempgreeting(struct ast_channel *chan, struct ast_vm_user *vmu, st
 	}
 
 	ast_test_suite_event_notify("TEMPGREETING", "Message: entering temp greeting options");
-	snprintf(prefile, sizeof(prefile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vms->username);
+	snprintf(prefile, sizeof(prefile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, vmu->mailbox);
 	while ((cmd >= 0) && (cmd != 't')) {
 		if (cmd)
 			retries = 0;
@@ -11847,7 +11875,8 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 			vms.repeats = 0;
 			while ((cmd > -1) && (cmd != 't') && (cmd != '#')) {
 				switch (cmd) {
-				case '1': /* Reply */
+				/*
+				case '1': //
 					if (vms.lastmsg > -1 && !vms.starting) {
 						cmd = advanced_options(chan, vmu, &vms, vms.curmsg, 1, record_gain);
 						if (cmd == ERROR_LOCK_PATH || cmd == OPERATOR_EXIT) {
@@ -11859,7 +11888,7 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 					}
 					cmd = 't';
 					break;
-				case '2': /* Callback */
+				case '2': // Callback
 					if (!vms.starting)
 						ast_verb(3, "Callback Requested\n");
 					if (!ast_strlen_zero(vmu->callback) && vms.lastmsg > -1 && !vms.starting) {
@@ -11876,7 +11905,7 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 					}
 					cmd = 't';
 					break;
-				case '3': /* Envelope */
+				case '3': // Envelope
 					if (vms.lastmsg > -1 && !vms.starting) {
 						cmd = advanced_options(chan, vmu, &vms, vms.curmsg, 3, record_gain);
 						if (cmd == ERROR_LOCK_PATH) {
@@ -11888,7 +11917,7 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 					}
 					cmd = 't';
 					break;
-				case '4': /* Dialout */
+				case '4': // Dialout
 					if (!ast_strlen_zero(vmu->dialout)) {
 						cmd = dialout(chan, vmu, NULL, vmu->dialout);
 						if (cmd == 9) {
@@ -11901,7 +11930,7 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 					cmd = 't';
 					break;
 
-				case '5': /* Leave VoiceMail */
+				case '5': // Leave VoiceMail
 					if (ast_test_flag(vmu, VM_SVMAIL)) {
 						cmd = forward_message(chan, context, &vms, vmu, vmfmts, 1, record_gain, 0);
 						if (cmd == ERROR_LOCK_PATH || cmd == OPERATOR_EXIT) {
@@ -11913,6 +11942,7 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 					}
 					cmd = 't';
 					break;
+				*/
 
 				case '*': /* Return to main menu */
 					cmd = 't';
@@ -11920,21 +11950,25 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 
 				default:
 					cmd = 0;
+					/*
 					if (!vms.starting) {
 						cmd = ast_play_and_wait(chan, "vm-toreply");
 					}
 					if (!ast_strlen_zero(vmu->callback) && !vms.starting && !cmd) {
 						cmd = ast_play_and_wait(chan, "vm-tocallback");
 					}
+					*/
 					if (!cmd && !vms.starting) {
 						cmd = ast_play_and_wait(chan, "vm-tohearenv");
 					}
+					/*
 					if (!ast_strlen_zero(vmu->dialout) && !cmd) {
 						cmd = ast_play_and_wait(chan, "vm-tomakecall");
 					}
 					if (ast_test_flag(vmu, VM_SVMAIL) && !cmd) {
 						cmd = ast_play_and_wait(chan, "vm-leavemsg");
 					}
+					*/
 					if (!cmd) {
 						cmd = ast_play_and_wait(chan, "vm-starmain");
 					}
@@ -12085,7 +12119,8 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 #endif
 			break;
 
-		case '8': /* Forward the current message */
+		/*
+		case '8': // Forward the current message
 			if (vms.lastmsg > -1) {
 				cmd = forward_message(chan, context, &vms, vmu, vmfmts, 0, record_gain, in_urgent);
 				if (cmd == ERROR_LOCK_PATH) {
@@ -12093,12 +12128,7 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 					goto out;
 				}
 			} else {
-				/* Check if we were listening to urgent
-				   messages.  If so, go to regular new messages
-				   instead of saying "no more messages"
-				*/
 				if (in_urgent == 1 && vms.newmessages > 0) {
-					/* Check for new messages */
 					in_urgent = 0;
 					res = close_mailbox(&vms, vmu);
 					if (res == ERROR_LOCK_PATH)
@@ -12116,6 +12146,7 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 				}
 			}
 			break;
+		*/
 		case '9': /* Save message to folder */
 			ast_test_suite_event_notify("SAVEMSG", "Message: saving message %d\r\nVoicemail: %d", vms.curmsg, vms.curmsg);
 			if (vms.curmsg < 0 || vms.curmsg > vms.lastmsg) {
@@ -12226,6 +12257,7 @@ static int vm_execmain(struct ast_channel *chan, const char *data)
 				cmd = 0;
 			break;
 		case '0': /* Mailbox options */
+			ast_log(LOG_DEBUG, "setting options for '%s'", vmu->mailbox);
 			cmd = vm_options(chan, vmu, &vms, vmfmts, record_gain);
 			if (useadsi)
 				adsi_status(chan, &vms);
@@ -12272,7 +12304,7 @@ out:
 		int new = 0, old = 0, urgent = 0;
 		snprintf(ext_context, sizeof(ext_context), "%s@%s", vms.username, vmu->context);
 		/* Urgent flag not passwd to externnotify here */
-		run_externnotify(vmu->context, vmu->mailbox, NULL);
+		run_externnotify(vmu->context, vmu->mailbox, NULL, vmu->dialed_num);
 		ast_app_inboxcount2(ext_context, &urgent, &new, &old);
 		queue_mwi_event(ast_channel_uniqueid(chan), ext_context, urgent, new, old);
 	}
@@ -13169,7 +13201,8 @@ static void poll_subscribed_mailbox(struct mwi_sub *mwi_sub)
 		mwi_sub->old_new = new;
 		mwi_sub->old_old = old;
 		queue_mwi_event(NULL, mwi_sub->mailbox, urgent, new, old);
-		run_externnotify(NULL, mwi_sub->mailbox, NULL);
+		// ksolomko: disabled as we do not have the number here
+		//run_externnotify(NULL, mwi_sub->mailbox, NULL, mwi_sub->dialed_num);
 	}
 }
 
@@ -16336,7 +16369,7 @@ static void notify_new_state(struct ast_vm_user *vmu)
 	char ext_context[1024];
 
 	snprintf(ext_context, sizeof(ext_context), "%s@%s", vmu->mailbox, vmu->context);
-	run_externnotify(vmu->context, vmu->mailbox, NULL);
+	run_externnotify(vmu->context, vmu->mailbox, NULL, vmu->dialed_num);
 	ast_app_inboxcount2(ext_context, &urgent, &new, &old);
 	queue_mwi_event(NULL, ext_context, urgent, new, old);
 }
